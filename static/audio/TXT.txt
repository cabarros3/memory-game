<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { get } from 'svelte/store';
  import { page } from '$app/stores';
  import { goto } from '$app/navigation';

  // üéÆ COMPONENTES
  import GameBus from './components/GameBus.svelte';
  import GameBar from '$lib/components/GameBar.svelte';
  import Modal from '$lib/components/Modal.svelte';
  import VictoryModal from './components/modalWinner.svelte';
  import NomeJogadorModal from '../../lib/components/modalNome.svelte';
  import { RankingManager } from '$lib/utils/ranking';


  // ‚è±Ô∏è TEMPORIZADOR
  import { criarTemporizador } from '$lib/utils/timer';

  // üß† CLASSES E FUN√á√ïES DO JOGO
  import { incrementarAcertosJogador, Jogador } from '$lib/classes/jogador';
  import { criarTabuleiro, resetarJogo, virarCarta as virarCartaJogo } from '$lib/utils/game_logic';
  import type { Tabuleiro } from '$lib/classes/tabuleiro';
  import { Cartas } from '$lib/classes/Cartas';

  const pathname = get(page).url.pathname;

  // üéÆ ESTADO DO JOGO
  let jogador: Jogador;
  let mostrarModalNome = true;
  let tabuleiro: Tabuleiro;
  let cartas: Cartas[] = [];
  let jogoIniciado = false;

  let jogoPausado: boolean = false;
  let tempo: string = '00:00';
  let tempoRestante: string = '01:00'; // 60 segundos
  let tempoEsgotado: boolean = false;
  let totalSegundos: number = 0;
  let nivel: number = 1;
  let tentativas: number = 0;
  let acertos: number = 0;
  let showVictoryModal: boolean = false;

  // ‚úÖ NOVA VARI√ÅVEL DE CONTROLE
  let jogoFinalizado: boolean = false;

  // ‚úÖ CONFIGURA√á√ÉO DO LIMITE (90 segundos para 6 pares)
  const TEMPO_LIMITE = 40; // segundos

  // üìã MODAL DE INSTRU√á√ïES
  let showIntroModal: boolean = false;
  let isFromHelpButton: boolean = false;


  // üéµ ESTADO DO √ÅUDIO (adicionar ap√≥s as outras vari√°veis)
  let backgroundMusic: HTMLAudioElement | null = null;
  let isMuted: boolean = false;
  let audioInitialized: boolean = false;

  // ‚úÖ CORRIGIDO: Todas as imagens na mesma pasta
  const imagensDisponiveis: string[] = [
    '/images/img1.jpg',
    '/images/img5.jpeg',
    '/images/img3.png',
    '/images/img4.jpg',
    '/images/img6.jpeg',
    '/images/chuu.png'
  ];

  // const temporizador = criarTemporizador((tempoFormatado, s) => {
  //   tempo = tempoFormatado;
  //   totalSegundos = s;
  // });

  // ‚úÖ TEMPORIZADOR ATUALIZADO COM CALLBACK EXPANDIDO
const temporizador = criarTemporizador(
  (tempoRestanteFormatado, segundosRestantes) => {
    tempoRestante = tempoRestanteFormatado;
    
    // Alerta quando restam 20 segundos
    if (segundosRestantes === 20 && !tempoEsgotado) {
      console.log('‚ö†Ô∏è 20 segundos restantes!');
    }
    
    // Alerta quando restam 10 segundos
    if (segundosRestantes === 10 && !tempoEsgotado) {
      console.log('üö® 10 segundos restantes!');
    }
  },
  TEMPO_LIMITE // 60 segundos
);


// üéµ FUN√á√ïES DE √ÅUDIO (adicionar junto com as outras fun√ß√µes)
function initAudio() {
  if (audioInitialized) return;
  
  try {
    backgroundMusic = new Audio('/audio/game_music.mp3');
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.15; // Volume baixo para n√£o incomodar
    
    // Eventos para debug
    backgroundMusic.addEventListener('loadstart', () => console.log('üéµ Carregando √°udio...'));
    backgroundMusic.addEventListener('canplay', () => console.log('üéµ √Åudio pronto para tocar'));
    backgroundMusic.addEventListener('error', (e) => console.error('‚ùå Erro no √°udio:', e));
    
    audioInitialized = true;
    console.log('üéµ √Åudio inicializado com sucesso');
  } catch (error) {
    console.error('‚ùå Erro ao inicializar √°udio:', error);
  }
}

function startMusic() {
  if (!backgroundMusic) initAudio();
  
  if (!isMuted && backgroundMusic && audioInitialized) {
    backgroundMusic.play().catch(e => {
      console.log('üéµ Autoplay bloqueado - usu√°rio precisa interagir primeiro');
    });
    console.log('üéµ M√∫sica iniciada');
  }
}

function stopMusic() {
  if (backgroundMusic) {
    backgroundMusic.pause();
    backgroundMusic.currentTime = 0;
    console.log('üéµ M√∫sica parada');
  }
}

function toggleMute() {
  isMuted = !isMuted;
  console.log(`üéµ Audio ${isMuted ? 'mutado' : 'desmutado'}`);
  
  if (backgroundMusic) {
    if (isMuted) {
      backgroundMusic.pause();
    } else if (!tempoEsgotado && !jogoFinalizado) {
      // S√≥ retoma a m√∫sica se o jogo ainda estiver ativo
      backgroundMusic.play().catch(e => console.log('‚ùå Erro ao retomar √°udio:', e));
    }
  }
}

// ‚úÖ FUN√á√ÉO PARA LIDAR COM NOME DEFINIDO
  function handleNomeDefinido(event: { detail: { nome: any; }; }) {
    const { nome } = event.detail;
    
    console.log('üéÆ Nome do jogador definido:', nome);
    
    // Cria o jogador com o nome fornecido
    jogador = new Jogador(nome);
    
    // Esconde o modal de nome
    mostrarModalNome = false;
    
    // Agora mostra o modal de instru√ß√µes
    showIntroModal = true;
    
    console.log('‚úÖ Jogador criado:', jogador);
  }

// function handlePlayAgain() {
//   console.log('üîÑ Jogador quer jogar novamente');
//   showVictoryModal = false;
  
//   // ‚úÖ RESET DAS VARI√ÅVEIS DE TEMPO
//   tempoEsgotado = false;
  
//   // ‚úÖ RESET DO JOGO
//   inicializarJogo();
  
//   try {
//     if (tabuleiro) {
//       // ‚úÖ resetarJogo n√£o retorna valor, ent√£o n√£o verificamos
//       resetarJogo(tabuleiro, jogador, imagensDisponiveis);
//       cartas = tabuleiro.cartas;
      
//       // ‚úÖ RESET E INICIAR TIMER
//       temporizador.resetar(); // Isso j√° define tempoRestante automaticamente via callback
//       temporizador.iniciar();
      
//       console.log('‚úÖ Jogo resetado com tabuleiro existente');
//       console.log('üìä Novas cartas:', cartas.length);
      
//     } else {
//       // Recrear tabuleiro se necess√°rio
//       tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//       cartas = tabuleiro.cartas;
      
//       // ‚úÖ RESET E INICIAR TIMER
//       temporizador.resetar(); // Isso j√° define tempoRestante automaticamente via callback
//       temporizador.iniciar();
      
//       console.log('‚úÖ Novo tabuleiro criado');
//       console.log('üìä Novas cartas:', cartas.length);
//     }
    
//     // ‚úÖ DEBUG DO ESTADO AP√ìS RESET
//     console.log('üîÑ Estado ap√≥s reset:');
//     console.log(`  - Acertos: ${acertos}`);
//     console.log(`  - Tentativas: ${tentativas}`);
//     console.log(`  - Tempo restante: ${tempoRestante}`);
//     console.log(`  - Jogo finalizado: ${jogoFinalizado}`);
//     console.log(`  - Tempo esgotado: ${tempoEsgotado}`);
    
//   } catch (error) {
//     console.error('‚ùå Erro ao resetar jogo:', error);
    
//     // ‚úÖ FALLBACK: criar novo tabuleiro
//     try {
//       tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//       cartas = tabuleiro.cartas;
      
//       temporizador.resetar();
//       temporizador.iniciar();
      
//       console.log('üÜò Tabuleiro recriado ap√≥s erro');
      
//     } catch (fallbackError) {
//       console.error('‚ùå Erro cr√≠tico no fallback:', fallbackError);
      
//       // ‚úÖ USAR CARTAS DE EMERG√äNCIA
//       cartas = criarCartasFallback();
      
//       temporizador.resetar();
//       temporizador.iniciar();
      
//       console.log('üö® Usando cartas de emerg√™ncia');
//     }
//   }
  
//   // ‚úÖ FOR√áA ATUALIZA√á√ÉO DAS VARI√ÅVEIS REATIVAS
//   setTimeout(() => {
//     acertos = jogador.acertos;
//     tentativas = jogador.tentativas;
//     console.log('üîÑ Vari√°veis reativas atualizadas:', { acertos, tentativas });
//   }, 100);
// }

// function handleTimeUp() {
//   if (jogoFinalizado || tempoEsgotado) return;
  
//   tempoEsgotado = true;
//   console.log('‚è∞ Tempo esgotado!');
  
//   jogoFinalizado = true;
  
//   setTimeout(() => {
//     alert(`‚è∞ Tempo Esgotado!

// Voc√™ n√£o conseguiu completar o jogo em ${TEMPO_LIMITE} segundos.

// üéØ Acertos: ${acertos} de 6 pares
// üìä Tentativas: ${tentativas}

// Tente novamente!`);
    
//     handlePlayAgain();
//   }, 300);
// }

  // ‚úÖ FUN√á√ÉO CORRIGIDA PARA INICIALIZAR ACERTOS
function handlePlayAgain() {
  console.log('üîÑ Jogador quer jogar novamente');
  showVictoryModal = false;
  
  // ‚úÖ RESET DAS VARI√ÅVEIS DE TEMPO
  tempoEsgotado = false;
  
  // ‚úÖ RESET DO JOGO
  inicializarJogo();
  
  try {
    if (tabuleiro) {
      resetarJogo(tabuleiro, jogador, imagensDisponiveis);
      cartas = tabuleiro.cartas;
      
      temporizador.resetar();
      temporizador.iniciar();
      
      // ‚úÖ REINICIAR M√öSICA
      if (!isMuted) {
        startMusic();
      }
      
      console.log('‚úÖ Jogo resetado com tabuleiro existente');
      console.log('üìä Novas cartas:', cartas.length);
      
    } else {
      tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
      cartas = tabuleiro.cartas;
      
      temporizador.resetar();
      temporizador.iniciar();
      
      // ‚úÖ REINICIAR M√öSICA
      if (!isMuted) {
        startMusic();
      }
      
      console.log('‚úÖ Novo tabuleiro criado');
      console.log('üìä Novas cartas:', cartas.length);
    }
    
    console.log('üîÑ Estado ap√≥s reset:');
    console.log(`  - Acertos: ${acertos}`);
    console.log(`  - Tentativas: ${tentativas}`);
    console.log(`  - Tempo restante: ${tempoRestante}`);
    console.log(`  - Jogo finalizado: ${jogoFinalizado}`);
    console.log(`  - Tempo esgotado: ${tempoEsgotado}`);
    console.log(`  - √Åudio mutado: ${isMuted}`);
    
  } catch (error) {
    console.error('‚ùå Erro ao resetar jogo:', error);
    
    try {
      tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
      cartas = tabuleiro.cartas;
      
      temporizador.resetar();
      temporizador.iniciar();
      
      if (!isMuted) {
        startMusic();
      }
      
      console.log('üÜò Tabuleiro recriado ap√≥s erro');
      
    } catch (fallbackError) {
      console.error('‚ùå Erro cr√≠tico no fallback:', fallbackError);
      
      cartas = criarCartasFallback();
      
      temporizador.resetar();
      temporizador.iniciar();
      
      if (!isMuted) {
        startMusic();
      }
      
      console.log('üö® Usando cartas de emerg√™ncia');
    }
  }

  
  
  setTimeout(() => {
    acertos = jogador.acertos;
    tentativas = jogador.tentativas;
    console.log('üîÑ Vari√°veis reativas atualizadas:', { acertos, tentativas });
  }, 100);
}

//   function handleTimeUp() {
//   if (jogoFinalizado || tempoEsgotado) return;
  
//   tempoEsgotado = true;
//   jogoFinalizado = true;
//   temporizador.pausar();
  
//   console.log('‚è∞ Tempo esgotado!');
//   console.log(`üìä Estado final: ${acertos}/${cartas.length / 2} pares encontrados`);
//   console.log(`üéØ Tentativas: ${tentativas}`);
  
//   // ‚úÖ ABRE O MODAL DE FIM DE JOGO (mesmo modal da vit√≥ria)
//   setTimeout(() => {
//     showVictoryModal = true;
//   }, 300);
// }
  
  function handleTimeUp() {
  if (jogoFinalizado || tempoEsgotado) return;
  
  tempoEsgotado = true;
  jogoFinalizado = true;
  temporizador.pausar();
  
  // ‚úÖ PARAR M√öSICA QUANDO TEMPO ESGOTAR
  stopMusic();
  
  console.log('‚è∞ Tempo esgotado!');
  console.log(`üìä Estado final: ${acertos}/${cartas.length / 2} pares encontrados`);
  console.log(`üéØ Tentativas: ${tentativas}`);
  
  setTimeout(() => {
    showVictoryModal = true;
  }, 300);
}

function inicializarJogo() {
    jogador = new Jogador('Jogador');
    acertos = jogador.acertos; // Sincroniza com o objeto jogador
    tentativas = jogador.tentativas;
    jogoFinalizado = false; // ‚úÖ RESET DA FLAG
    console.log('üéÆ Jogo inicializado - Acertos:', acertos, 'Tentativas:', tentativas);
  }


  function openFromHelpButton() {
    showIntroModal = true;
    isFromHelpButton = true;
  }

  // function closeModal() {
  //   showIntroModal = false;
  //   isFromHelpButton = false;
  //   temporizador.iniciar()
  // }

  // üîç FUN√á√ÉO DE DEBUG PARA VERIFICAR PARES
  function closeModal() {
  showIntroModal = false;
  isFromHelpButton = false;
  temporizador.iniciar();
  
  // ‚úÖ INICIAR M√öSICA QUANDO O JOGO COME√áAR
  startMusic();
}

  
  
  function debugPares(cartas: Cartas[]) {
    console.log('\nüîç === DEBUG DOS PARES ===');
    console.log('üìä Total de cartas:', cartas.length);
    
    // Agrupa cartas por pairId
    const grupos = cartas.reduce((acc, carta, index) => {
      if (!acc[carta.parId]) {
        acc[carta.parId] = [];
      }
      acc[carta.parId].push({ 
        index, 
        imagem: carta.imagem, 
        status: carta.status,
        id: carta.id 
      });
      return acc;
    }, {} as Record<string, Array<{index: number, imagem: string, status: string, id: string}>>);
    
    console.log('üß© Grupos por pairId:');
    Object.entries(grupos).forEach(([pairId, cartas]) => {
      const mesmaImagem = new Set(cartas.map(c => c.imagem)).size === 1;
      const quantidadeCorreta = cartas.length === 2;
      
      console.log(`  ${pairId}: ${cartas.length} cartas ${quantidadeCorreta ? '‚úÖ' : '‚ùå'} | Mesma imagem: ${mesmaImagem ? '‚úÖ' : '‚ùå'}`);
      
      cartas.forEach(carta => {
        console.log(`    - √çndice ${carta.index}: ${carta.imagem} (${carta.status}) [ID: ${carta.id}]`);
      });
    });
    
    // Verifica problemas
    const problemaPares = Object.values(grupos).some(grupo => grupo.length !== 2);
    const problemaImagens = Object.values(grupos).some(grupo => 
      new Set(grupo.map(c => c.imagem)).size !== 1
    );
    
    if (problemaPares) {
      console.error('‚ùå PROBLEMA: Alguns pares n√£o t√™m exatamente 2 cartas!');
    }
    
    if (problemaImagens) {
      console.error('‚ùå PROBLEMA: Algumas cartas do mesmo par t√™m imagens diferentes!');
    }
    
    if (!problemaPares && !problemaImagens) {
      console.log('‚úÖ Todos os pares est√£o corretos!');
    }
    
    console.log('=== FIM DEBUG DOS PARES ===\n');
    
    return grupos;
  }

  // ‚úÖ FUN√á√ÉO PARA CRIAR CARTAS DE FALLBACK CORRETAMENTE
  function criarCartasFallback(): Cartas[] {
    console.log('üèóÔ∏è Criando cartas fallback...');
    
    // Garante que temos exatamente 6 imagens √∫nicas
    const imagensUnicas = imagensDisponiveis.slice(0, 6);
    console.log('üñºÔ∏è Imagens selecionadas:', imagensUnicas);
    
    const cartasArray: Cartas[] = [];
    
    // Cria exatamente 2 cartas para cada imagem
    imagensUnicas.forEach((imagem, index) => {
      const pairId = `pair-${index}`;
      
      console.log(`üé¥ Criando par ${index + 1}: ${imagem}`);
      
      // Primeira carta do par
      const carta1 = new Cartas(
        `carta-${index}-a`, // ID √∫nico para primeira carta
        imagem,
        pairId,
        'hidden'
      );
      
      // Segunda carta do par  
      const carta2 = new Cartas(
        `carta-${index}-b`, // ID √∫nico para segunda carta
        imagem,
        pairId,
        'hidden'
      );
      
      cartasArray.push(carta1, carta2);
      
      console.log(`  ‚úÖ Criadas: ${carta1.id} e ${carta2.id} (${pairId})`);
    });
    
    console.log('üì¶ Cartas antes do embaralhamento:', cartasArray.length);
    
    // üé≤ EMBARALHAMENTO USANDO FISHER-YATES (mais robusto)
    const cartasEmbaralhadas = [...cartasArray];
    for (let i = cartasEmbaralhadas.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [cartasEmbaralhadas[i], cartasEmbaralhadas[j]] = [cartasEmbaralhadas[j], cartasEmbaralhadas[i]];
    }
    
    console.log('üé≤ Cartas embaralhadas com sucesso!');
    
    // Debug final
    debugPares(cartasEmbaralhadas);
    
    return cartasEmbaralhadas;
  }

  // ‚úÖ FUN√á√ÉO FIM DE JOGO COM PROTE√á√ÉO
//   function fimDeJogo() {
//     if (jogoFinalizado) {
//       console.log('‚ö†Ô∏è Fim de jogo j√° foi executado, ignorando...');
//       return;
//     }
    
//     jogoFinalizado = true; // ‚úÖ MARCA COMO FINALIZADO
//     temporizador.pausar();

//     console.log('üèÜ Fim de jogo!');
    
//     // ‚úÖ DEBUG DETALHADO DO ESTADO FINAL
//     const cartasMatched = cartas.filter(c => c.status === 'matched').length;
//     console.log(`üìä Estado final: ${cartasMatched}/${cartas.length} cartas matched`);
//     console.log(`üéØ Acertos do jogador: ${jogador.acertos}`);
//     console.log(`üìä Tentativas: ${jogador.tentativas}`);

//     // ‚úÖ DELAY PARA GARANTIR QUE TUDO FOI PROCESSADO
//     setTimeout(() => {
//       alert(`üèÜ Parab√©ns, ${jogador.nome}!
// ‚è±Ô∏è Tempo: ${tempo}
// üéØ Acertos: ${jogador.acertos} pares
// üìä Tentativas: ${jogador.tentativas}
// üèÖ Precis√£o: ${jogador.tentativas ? Math.round((jogador.acertos * 2 / jogador.tentativas) * 100) : 0}%

// Voc√™ completou o n√≠vel!`);
      
//       // Aqui voc√™ pode redirecionar ou abrir um modal de "fim de jogo"
//       // goto('/levels'); // exemplo
//     }, 300);
//   }

// function fimDeJogo() {
//   if (jogoFinalizado) {
//     console.log('‚ö†Ô∏è Fim de jogo j√° foi executado, ignorando...');
//     return;
//   }
  
//   jogoFinalizado = true;
//   temporizador.pausar();

//   console.log('üèÜ Fim de jogo!');
  
//   // ‚úÖ DEBUG DETALHADO DO ESTADO FINAL
//   const cartasMatched = cartas.filter(c => c.status === 'matched').length;
//   console.log(`üìä Estado final: ${cartasMatched}/${cartas.length} cartas matched`);
//   console.log(`üéØ Acertos do jogador: ${jogador.acertos}`);
//   console.log(`üìä Tentativas: ${jogador.tentativas}`);

//   // ‚úÖ DELAY PARA GARANTIR QUE TUDO FOI PROCESSADO E ABRE O MODAL
//   setTimeout(() => {
//     showVictoryModal = true;
//   }, 300);
// }

function fimDeJogo() {
  if (jogoFinalizado) {
    console.log('‚ö†Ô∏è Fim de jogo j√° foi executado, ignorando...');
    return;
  }
  
  jogoFinalizado = true;
  temporizador.pausar();
  
  // ‚úÖ PARAR M√öSICA NO FIM DO JOGO
  stopMusic();

  console.log('üèÜ Fim de jogo!');
  
  const cartasMatched = cartas.filter(c => c.status === 'matched').length;
  console.log(`üìä Estado final: ${cartasMatched}/${cartas.length} cartas matched`);
  console.log(`üéØ Acertos do jogador: ${jogador.acertos}`);
  console.log(`üìä Tentativas: ${jogador.tentativas}`);

  setTimeout(() => {
    showVictoryModal = true;
  }, 300);
}

// ‚úÖ FUN√á√ïES PARA LIDAR COM OS EVENTOS DO MODAL
// ‚úÖ FUN√á√ÉO CORRIGIDA PARA LIDAR COM JOGAR NOVAMENTE
// function handlePlayAgain() {
//   console.log('üîÑ Jogador quer jogar novamente');
//   showVictoryModal = false;
  
//   // Resetar o jogo
//   inicializarJogo();
  
//   try {
//     if (tabuleiro) {
//       // ‚úÖ resetarJogo n√£o retorna valor, ent√£o n√£o verificamos
//       resetarJogo(tabuleiro, jogador, imagensDisponiveis);
//       cartas = tabuleiro.cartas;
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('‚úÖ Jogo resetado com tabuleiro existente');
//     } else {
//       // Recrear tabuleiro se necess√°rio
//       tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//       cartas = tabuleiro.cartas;
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('‚úÖ Novo tabuleiro criado');
//     }
//   } catch (error) {
//     console.error('‚ùå Erro ao resetar jogo:', error);
    
//     // ‚úÖ FALLBACK: criar novo tabuleiro
//     try {
//       tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//       cartas = tabuleiro.cartas;
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('üÜò Tabuleiro recriado ap√≥s erro');
//     } catch (fallbackError) {
//       console.error('‚ùå Erro cr√≠tico no fallback:', fallbackError);
//       // Usar cartas de emerg√™ncia
//       cartas = criarCartasFallback();
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('üö® Usando cartas de emerg√™ncia');
//     }
//   }
// }

// function handlePlayAgain() {
//   console.log('üîÑ Jogador quer jogar novamente');
//   showVictoryModal = false;
  
//   // ‚úÖ RESET DAS VARI√ÅVEIS DE TEMPO
//   tempoEsgotado = false;
//   tempoRestante = temporizador.formatarTempoRestante(TEMPO_LIMITE);
  
//   // Resetar o jogo
//   inicializarJogo();
  
//   try {
//     if (tabuleiro) {
//       resetarJogo(tabuleiro, jogador, imagensDisponiveis);
//       cartas = tabuleiro.cartas;
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('‚úÖ Jogo resetado com tabuleiro existente');
//     } else {
//       tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//       cartas = tabuleiro.cartas;
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('‚úÖ Novo tabuleiro criado');
//     }
//   } catch (error) {
//     console.error('‚ùå Erro ao resetar jogo:', error);
//     try {
//       tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//       cartas = tabuleiro.cartas;
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('üÜò Tabuleiro recriado ap√≥s erro');
//     } catch (fallbackError) {
//       console.error('‚ùå Erro cr√≠tico no fallback:', fallbackError);
//       cartas = criarCartasFallback();
//       temporizador.resetar();
//       temporizador.iniciar();
//       console.log('üö® Usando cartas de emerg√™ncia');
//     }
//   }
// }



function handleGoHome() {
  console.log('üè† Voltando para o menu principal');
  showVictoryModal = false;
  goto('/');
}


  // ‚úÖ FUN√á√ÉO VIRAR CARTA COM DETEC√á√ÉO MELHORADA
  // function virarCarta(index: number) {
  //   // ‚úÖ PROTE√á√ÉO CONTRA JOGO J√Å FINALIZADO
  //   if (jogoFinalizado) {
  //     console.log('üõë Jogo j√° finalizado, ignorando jogada');
  //     return;
  //   }
    
  //   console.log(`\nüéØ === VIRANDO CARTA ${index} ===`);

  //   if (!tabuleiro || !jogador) {
  //     console.error('‚ùå Tabuleiro ou jogador n√£o inicializados!');
  //     return;
  //   }

  //   // ‚úÖ VALIDA√á√ÉO DO √çNDICE
  //   if (index < 0 || index >= cartas.length) {
  //     console.error(`‚ùå √çndice inv√°lido: ${index}. Total de cartas: ${cartas.length}`);
  //     return;
  //   }

  //   // ‚úÖ VERIFICA SE A CARTA PODE SER VIRADA
  //   const carta = cartas[index];
  //   if (carta.status === 'matched' || carta.status === 'visible') {
  //     console.log(`‚ö†Ô∏è Carta ${index} j√° est√° ${carta.status}, ignorando`);
  //     return;
  //   }

  //   const sucesso = virarCartaJogo(tabuleiro, index, jogador);

  //   if (sucesso) {
  //     console.log('‚úÖ Carta virada com sucesso');
      
  //     // ‚úÖ ATUALIZA VARI√ÅVEIS REATIVAS
  //     tentativas = jogador.tentativas;
  //     acertos = jogador.acertos; // ‚úÖ SINCRONIZA ACERTOS

  //     // Atualiza array de cartas com nova inst√¢ncia para for√ßar reatividade
  //     cartas = tabuleiro.cartas.map(carta => new Cartas(
  //       carta.id,
  //       carta.imagem,
  //       carta.parId,
  //       carta.status
  //     ));

  //     console.log(`üìä Ap√≥s jogada: Acertos ${acertos}, Tentativas ${tentativas}`);

  //     // ‚úÖ VERIFICA√á√ÉO M√öLTIPLA DE FIM DE JOGO
      
  //     // M√©todo 1: Todas as cartas est√£o matched
  //     const todasMatched = cartas.every(c => c.status === 'matched');
  //     console.log(`üîç M√©todo 1 - Todas matched: ${todasMatched}`);
      
  //     // M√©todo 2: Contagem de cartas matched
  //     const cartasMatchedAgora = cartas.filter(c => c.status === 'matched').length;
  //     const fimPorContagem = cartasMatchedAgora === cartas.length && cartas.length > 0;
  //     console.log(`üîç M√©todo 2 - Por contagem: ${cartasMatchedAgora}/${cartas.length} = ${fimPorContagem}`);
      
  //     // M√©todo 3: Por acertos do jogador
  //     const totalPares = cartas.length / 2;
  //     const fimPorAcertos = jogador.acertos >= totalPares;
  //     console.log(`üîç M√©todo 3 - Por acertos: ${jogador.acertos}/${totalPares} = ${fimPorAcertos}`);
      
  //     // ‚úÖ FIM DE JOGO SE PELO MENOS 2 M√âTODOS CONCORDAREM
  //     const metodosPositivos = [todasMatched, fimPorContagem, fimPorAcertos].filter(Boolean).length;
      
  //     if (metodosPositivos >= 2) {
  //       console.log(`üèÜ ${metodosPositivos}/3 m√©todos detectaram fim de jogo!`);
  //       setTimeout(() => {
  //         if (!jogoFinalizado) { // ‚úÖ PROTE√á√ÉO DUPLA
  //           fimDeJogo();
  //         }
  //       }, 200);
  //     } else {
  //       console.log(`‚è≥ Apenas ${metodosPositivos}/3 m√©todos detectaram fim. Continuando...`);
  //     }

  //   } else {
  //     console.log('‚ùå virarCartaJogo retornou false');
  //   }
    
  //   console.log('=== FIM VIRAR CARTA ===\n');
  // }

  // ‚úÖ FUN√á√ÉO VIRAR CARTA CORRIGIDA
function virarCarta(index: number) {

  // ‚úÖ PROTE√á√ÉO CONTRA TEMPO ESGOTADO
  if (tempoEsgotado) {
    console.log('‚è∞ Tempo esgotado, n√£o √© poss√≠vel virar cartas');
    return;
  }
  
  if (jogoFinalizado) {
    console.log('üõë Jogo j√° finalizado, ignorando jogada');
    return;
  }

  // ‚úÖ PROTE√á√ÉO CONTRA JOGO J√Å FINALIZADO
  if (jogoFinalizado) {
    console.log('üõë Jogo j√° finalizado, ignorando jogada');
    return;
  }
  
  console.log(`\nüéØ === VIRANDO CARTA ${index} ===`);

  if (!tabuleiro || !jogador) {
    console.error('‚ùå Tabuleiro ou jogador n√£o inicializados!');
    return;
  }

  // ‚úÖ VALIDA√á√ÉO DO √çNDICE
  if (index < 0 || index >= cartas.length) {
    console.error(`‚ùå √çndice inv√°lido: ${index}. Total de cartas: ${cartas.length}`);
    return;
  }

  // ‚úÖ VERIFICA SE A CARTA PODE SER VIRADA
  const carta = cartas[index];
  if (carta.status === 'matched' || carta.status === 'visible') {
    console.log(`‚ö†Ô∏è Carta ${index} j√° est√° ${carta.status}, ignorando`);
    return;
  }

  const sucesso = virarCartaJogo(tabuleiro, index, jogador);

  if (sucesso) {
    console.log('‚úÖ Carta virada com sucesso');
    
    // ‚úÖ AGUARDA O PROCESSAMENTO COMPLETO DOS ACERTOS
    // Usa um delay maior que o setTimeout interno (100ms + margem)
    setTimeout(() => {
      console.log('üîÑ Sincronizando ap√≥s processamento...');
      
      // ‚úÖ ATUALIZA VARI√ÅVEIS REATIVAS
      tentativas = jogador.tentativas;
      acertos = jogador.acertos; // ‚úÖ AGORA VAI PEGAR O VALOR CORRETO

      // Atualiza array de cartas com nova inst√¢ncia para for√ßar reatividade
      cartas = tabuleiro.cartas.map(carta => new Cartas(
        carta.id,
        carta.imagem,
        carta.parId,
        carta.status
      ));

      console.log(`üìä Ap√≥s sincroniza√ß√£o: Acertos ${acertos}, Tentativas ${tentativas}`);
      
      // ‚úÖ DEBUG: Verificar consist√™ncia
      const cartasMatched = cartas.filter(c => c.status === 'matched').length;
      const paresMatched = cartasMatched / 2;
      
      console.log(`üîç Verifica√ß√£o:`);
      console.log(`  - jogador.acertos: ${jogador.acertos}`);
      console.log(`  - pares nas cartas: ${paresMatched}`);
      console.log(`  - vari√°vel acertos: ${acertos}`);
      
      if (Math.abs(jogador.acertos - paresMatched) > 0.1) {
        console.warn('‚ö†Ô∏è Poss√≠vel inconsist√™ncia detectada, for√ßando sincroniza√ß√£o...');
        jogador.acertos = Math.floor(paresMatched);
        acertos = jogador.acertos;
        console.log(`üîß Acertos corrigidos para: ${acertos}`);
      }

      // ‚úÖ VERIFICA√á√ÉO DE FIM DE JOGO (simplificada)
      const todasMatched = cartas.every(c => c.status === 'matched');
      
      if (todasMatched && cartas.length > 0) {
        console.log('üèÜ Todas as cartas est√£o matched - fim de jogo!');
        setTimeout(() => {
          if (!jogoFinalizado) {
            fimDeJogo();
          }
        }, 200);
      }
      
    }, 200); // ‚úÖ DELAY MAIOR QUE O setTimeout interno (100ms)

  } else {
    console.log('‚ùå virarCartaJogo retornou false');
  }
  
  console.log('=== FIM VIRAR CARTA ===\n');
}

  // function handlePause() {
  //   if (jogoPausado) {
  //     temporizador.iniciar();
  //   } else {
  //     temporizador.pausar();
  //   }
  //   jogoPausado = !jogoPausado;
  // }

function handlePause() {
  if (jogoPausado) {
    temporizador.iniciar();
    // ‚úÖ RETOMAR M√öSICA SE N√ÉO ESTIVER MUTADA
    if (!isMuted && backgroundMusic) {
      backgroundMusic.play().catch(e => console.log('Erro ao retomar m√∫sica:', e));
    }
  } else {
    temporizador.pausar();
    // ‚úÖ PAUSAR M√öSICA
    if (backgroundMusic) {
      backgroundMusic.pause();
    }
  }
  jogoPausado = !jogoPausado;
}


  // function handleExit() {
  //   temporizador.pausar();
  //   if (pathname.includes('/adventure')) {
  //     goto('/');
  //   } else {
  //     goto('/levels');
  //   }
  // }


//   onMount(async () => {
//   console.log('üöÄ Montando componente Adventure...');
  
//   try {
//     inicializarJogo();
//     console.log('‚úÖ Jogador criado:', jogador);
    
//     tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
//     console.log('‚úÖ Tabuleiro criado:', tabuleiro);
    
//     if (tabuleiro && tabuleiro.cartas && tabuleiro.cartas.length > 0) {
//       cartas = tabuleiro.cartas;
//       console.log('‚úÖ Cartas atribu√≠das do tabuleiro:', cartas.length);
//     } else {
//       console.warn('‚ö†Ô∏è Tabuleiro ou cartas s√£o undefined! Usando fallback...');
//       cartas = criarCartasFallback();
//       console.log('‚úÖ Usando cartas fallback:', cartas.length);
//     }
    
//     // ‚úÖ CONFIGURA CALLBACK DE TEMPO ESGOTADO
//     temporizador.setTimeUpCallback(handleTimeUp);
    
//     // ‚úÖ INICIALIZA TEMPO RESTANTE
//     tempoRestante = temporizador.formatarTempoRestante(TEMPO_LIMITE);
    
//     acertos = jogador.acertos;
//     tentativas = jogador.tentativas;
    
//     console.log(`üìä Estado inicial:`);
//     console.log(`  - Total de cartas: ${cartas.length}`);
//     console.log(`  - Pares esperados: ${cartas.length / 2}`);
//     console.log(`  - Tempo limite: ${TEMPO_LIMITE} segundos`);
//     console.log(`  - Acertos iniciais: ${acertos}`);
    
//   } catch (error) {
//     console.error('‚ùå Erro ao inicializar jogo:', error);
    
//     if (!jogador) {
//       inicializarJogo();
//     }
    
//     cartas = criarCartasFallback();
//     temporizador.setTimeUpCallback(handleTimeUp);
//     tempoRestante = temporizador.formatarTempoRestante(TEMPO_LIMITE);
//     console.log('üÜò Usando cartas de emerg√™ncia:', cartas.length);
//   }
// });

function handleExit() {
  temporizador.pausar();
  
  // ‚úÖ PARAR M√öSICA AO SAIR
  stopMusic();
  
  if (pathname.includes('/adventure')) {
    goto('/');
  } else {
    goto('/levels');
  }
}


onMount(async () => {
  console.log('üöÄ Montando componente Adventure...');
  
  try {
    inicializarJogo();
    console.log('‚úÖ Jogador criado:', jogador);
    
    tabuleiro = criarTabuleiro('tabuleiro-1', 'adventure', imagensDisponiveis);
    console.log('‚úÖ Tabuleiro criado:', tabuleiro);
    
    if (tabuleiro && tabuleiro.cartas && tabuleiro.cartas.length > 0) {
      cartas = tabuleiro.cartas;
      console.log('‚úÖ Cartas atribu√≠das do tabuleiro:', cartas.length);
    } else {
      console.warn('‚ö†Ô∏è Tabuleiro ou cartas s√£o undefined! Usando fallback...');
      cartas = criarCartasFallback();
      console.log('‚úÖ Usando cartas fallback:', cartas.length);
    }
    
    // ‚úÖ CONFIGURA CALLBACK DE TEMPO ESGOTADO
    temporizador.setTimeUpCallback(handleTimeUp);
    
    // ‚úÖ INICIALIZA TEMPO RESTANTE usando a fun√ß√£o correta
    tempoRestante = temporizador.formatarTempo(TEMPO_LIMITE);
    
    acertos = jogador.acertos;
    tentativas = jogador.tentativas;
    
    console.log(`üìä Estado inicial:`);
    console.log(`  - Total de cartas: ${cartas.length}`);
    console.log(`  - Pares esperados: ${cartas.length / 2}`);
    console.log(`  - Tempo limite: ${TEMPO_LIMITE} segundos`);
    console.log(`  - Tempo restante inicial: ${tempoRestante}`);
    console.log(`  - Acertos iniciais: ${acertos}`);
    
  } catch (error) {
    console.error('‚ùå Erro ao inicializar jogo:', error);
    
    if (!jogador) {
      inicializarJogo();
    }
    
    cartas = criarCartasFallback();
    temporizador.setTimeUpCallback(handleTimeUp);
    
    // ‚úÖ CORRIGIDO: usar formatarTempo em vez de formatarTempoRestante
    tempoRestante = temporizador.formatarTempo(TEMPO_LIMITE);
    
    console.log('üÜò Usando cartas de emerg√™ncia:', cartas.length);
    console.log('üÜò Tempo restante definido como:', tempoRestante);
  }
});

  onDestroy(() => {
  temporizador.pausar();
  
  // ‚úÖ LIMPAR √ÅUDIO
  stopMusic();
  if (backgroundMusic) {
    backgroundMusic = null;
  }
  audioInitialized = false;
});

  // ‚úÖ DEBUG REATIVO COM MONITORAMENTO DE FIM DE JOGO
  $: {
    if (cartas && cartas.length > 0) {
      const statusCount = cartas.reduce((acc, carta) => {
        acc[carta.status] = (acc[carta.status] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
      
      console.log('üéØ Estado atual das cartas:', statusCount);
      console.log('üìä Detalhes por carta:', cartas.map((c, i) => `${i}: ${c.status}`));
      
      // Debug dos pares
      const pares = cartas.reduce((acc, carta) => {
        if (!acc[carta.parId]) {
          acc[carta.parId] = [];
        }
        acc[carta.parId].push({ imagem: carta.imagem, status: carta.status });
        return acc;
      }, {} as Record<string, Array<{imagem: string, status: string}>>);
      
      console.log('üß© Pares identificados:', pares);
      
      // ‚úÖ MONITOR REATIVO DE FIM DE JOGO
      const matched = cartas.filter(c => c.status === 'matched').length;
      if (matched === cartas.length && matched > 0 && !jogoFinalizado) {
        console.log('üéØ Monitor reativo detectou todas as cartas matched!');
        console.log(`üìä Estado: ${matched}/${cartas.length} cartas matched`);
        
        // ‚úÖ BACKUP DE FINALIZA√á√ÉO VIA REATIVIDADE
        setTimeout(() => {
          if (!jogoFinalizado) {
            console.log('üöÄ Executando fim de jogo pelo monitor reativo');
            fimDeJogo();
          }
        }, 150);
      }
    }
  }
</script>

<!-- MODAL DE INTRODU√á√ÉO (existente) -->
<Modal
  open={showIntroModal}
  title="üß† How to Play?"
  showCloseButton={isFromHelpButton}
  on:close={closeModal}
>
 <div class="flex flex-col gap-3 text-gray-800 font-medium">
  <p>üéÆ <strong>Welcome to the MemoGame: Botafire!</strong> üî•</p>
  <p>The legend is real. A beast that conquers the hills of the BR-101. Welcome to <em>The BotaFire.</em></p>
  <p>Now, the challenge is <strong>YOUR'S</strong>. Dive into this epic game and prove your memory is worthy of the legend. ‚öîÔ∏èüß†</p>
  <p>Your mission: <strong>Tame the chaos!</strong> </p>
  <p>üêâ Tap or click on two cards to reveal the icons of our daily campus survival‚Äîfrom the legendary <span class="italic">coxinha</span> ü•ê to the little dog who's the real dean üêï‚Äçü¶∫.</p>
  <p>If they match, they stay open. If not, they'll flip back into the shadows, so you must remember their positions.</p>
  <p>Pay close attention and plan your moves wisely. Speed is your enemy. Memory is your only weapon. Try to clear the board with the fewest attempts possible.</p>
  <p>üöÄ Ready to play? Jump in now and make history! üéâ</p>
</div>


  <div slot="footer">
    {#if !isFromHelpButton}
      <button
        class="px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700"
        on:click={closeModal}
      >
        I'm ready!
      </button>
    {/if}
  </div>
</Modal>

<!-- ‚úÖ MODAL DE VIT√ìRIA -->
<VictoryModal
  open={showVictoryModal}
  {acertos}
  {tentativas}
  precisao={tentativas > 0 ? Math.round((acertos * 2 / tentativas) * 100) : 0}
  {nivel}
  {tempoEsgotado}
  totalPares={6}
  isAdventure={true}
  on:playAgain={handlePlayAgain}
  on:goHome={handleGoHome}
/>

<!-- GAMEBAR E JOGO -->
<div class="flex min-h-screen flex-col items-center bg-[url('/vectors/img4.png')] bg-cover bg-center">
  <GameBar
    {tempoRestante}
    {nivel}
    {tentativas}
    {acertos}
    {jogoPausado}
    {isMuted}
    on:reabrirModal={openFromHelpButton}
    on:pause={handlePause}
    on:exit={handleExit}
    on:toggleAudio={toggleMute}
  />

  {#if cartas && cartas.length > 0}
    <GameBus cartasClasse={cartas} {virarCarta} />
  {:else}
    <div class="bg-yellow-100 p-4 rounded">
      <p>Carregando cartas... ou erro na inicializa√ß√£o</p>
      <p class="text-sm text-gray-600">Verifique se as imagens existem na pasta /images/</p>
    </div>
  {/if}
</div>




<script lang="ts">
  import WindowGroup from './WindowGroup.svelte';
  import Door from './Door.svelte';
  import type { Cartas } from '$lib/classes/Cartas';

  // Props: cartas no formato da classe original e fun√ß√£o para virar carta
  export let cartasClasse: Cartas[] = [];
  export let virarCarta: (index: number) => void;

  // Usar diretamente as cartas da classe, sem convers√£o
  $: cartas = cartasClasse;
</script>

<!-- Container do √¥nibus - Aumentado significativamente -->
<div class="relative mt-20 max-w-[1200px] rounded-2xl bg-white
 px-12 py-12 shadow-2xl">
  <!-- Grid principal com mais espa√ßo -->
  <div class="grid grid-cols-[auto_120px_auto_120px_auto_120px] gap-x-8 items-start">
    {#if cartas && cartas.length >= 12}
      <!-- Grupos de janelas com espa√ßamento maior -->
      <div class="window-group-large">
        <WindowGroup baseIndex={0} {cartas} {virarCarta} />
      </div>
      
      <!-- Porta maior -->
      <div class="door-large flex justify-center">
        <Door />
      </div>
      
      <div class="window-group-large">
        <WindowGroup baseIndex={4} {cartas} {virarCarta} />
      </div>
      
      <div class="door-large flex justify-center">
        <Door />
      </div>
      
      <div class="window-group-large">
        <WindowGroup baseIndex={8} {cartas} {virarCarta} />
      </div>
      
      <!-- Porta adicional para equilibrar o design -->
      <div class="door-large flex justify-center">
        <Door />
      </div>
    {:else}
      <div class="col-span-6 p-8 text-center">
        <p class="text-xl">Carregando jogo...</p>
        <p class="text-lg text-gray-500 mt-2">Cartas: {cartas?.length || 0}/12</p>
      </div>
    {/if}
  </div>

  <!-- Detalhes adicionais do √¥nibus -->
  <!-- Far√≥is dianteiros -->
  <!-- <div class="absolute top-8 left-8 h-6 w-6 rounded-full bg-yellow-300 shadow-lg"></div>
  <div class="absolute top-16 left-8 h-6 w-6 rounded-full bg-yellow-300 shadow-lg"></div> -->
  
  <!-- Far√≥is traseiros -->
  <!-- <div class="absolute top-8 right-8 h-6 w-6 rounded-full bg-red-500 shadow-lg"></div>
  <div class="absolute top-16 right-8 h-6 w-6 rounded-full bg-red-500 shadow-lg"></div> -->

  <!-- Para-choque dianteiro -->
  <div class="absolute bottom-4 left-0 h-3 w-32 rounded-r-lg bg-gray-400"></div>
  
  <!-- Para-choque traseiro -->
  <div class="absolute bottom-4 right-0 h-3 w-32 rounded-l-lg bg-gray-400"></div>

  <!-- Rodas maiores e mais detalhadas -->
  <div class="absolute bottom-[-32px] left-40 h-24 w-24 rounded-full bg-black shadow-xl border-4 border-gray-600">
    <!-- Roda interna -->
    <div class="absolute inset-2 rounded-full bg-gray-700"></div>
    <!-- Centro da roda -->
    <div class="absolute inset-1/2 h-2 w-2 -translate-x-1/2 -translate-y-1/2 rounded-full bg-gray-400"></div>
  </div>
  
  <div class="absolute bottom-[-32px] right-40 h-24 w-24 rounded-full bg-black shadow-xl border-4 border-gray-600">
    <!-- Roda interna -->
    <div class="absolute inset-2 rounded-full bg-gray-700"></div>
    <!-- Centro da roda -->
    <div class="absolute inset-1/2 h-2 w-2 -translate-x-1/2 -translate-y-1/2 rounded-full bg-gray-400"></div>
  </div>

  <!-- Linha decorativa lateral -->
  <!-- <div class="absolute top-1/2 left-0 h-1 w-full bg-gradient-to-r from-blue-500 via-green-500 to-blue-500 -translate-y-1/2"></div> -->
</div>

<style>
  /* Usar tamanhos f√≠sicos ao inv√©s de transform scale */
  .window-group-large {
    transform: scale(1);
    font-size: 1.25em;
  }
  
  .door-large {
    transform: scale(1);
    width: 120px;
    height: auto;
  }
  
  /* Anima√ß√µes suaves para melhor experi√™ncia */
  .relative {
    transition: all 0.3s ease-in-out;
  }
  
  /* Responsividade para telas menores */
  @media (max-width: 1280px) {
    .max-w-\[1200px\] {
      max-width: 900px;
    }
    
    .window-group-large {
      font-size: 1.1em;
    }
  }
  
  @media (max-width: 768px) {
    .max-w-\[1200px\] {
      max-width: 100%;
      margin: 1rem;
    }
    
    .window-group-large {
      font-size: 0.9em;
    }
    
    .grid-cols-\[auto_120px_auto_120px_auto_120px\] {
      grid-template-columns: auto 80px auto 80px auto 80px;
    }
    
    .gap-x-8 {
      gap: 1rem;
    }
  }




  <script lang="ts">
  import WindowGroup from './WindowGroup.svelte';
  import Door from './Door.svelte';
  import type { Cartas } from '$lib/classes/Cartas';

  // Props: cartas no formato da classe original e fun√ß√£o para virar carta
  export let cartasClasse: Cartas[] = [];
  export let virarCarta: (index: number) => void;

  // Usar diretamente as cartas da classe, sem convers√£o
  $: cartas = cartasClasse;
</script>

<!-- Container do √¥nibus - Aumentado significativamente -->
<div class="relative mt-20 max-w-[1200px] rounded-2xl bg-white
 px-12 py-12 shadow-2xl">
  <!-- Grid principal com mais espa√ßo -->
  <div class="grid grid-cols-[auto_120px_auto_120px_auto_120px] gap-x-8 items-start">
    {#if cartas && cartas.length >= 12}
      <!-- Grupos de janelas com espa√ßamento maior -->
      <div class="window-group-large">
        <WindowGroup baseIndex={0} {cartas} {virarCarta} />
      </div>
      
      <!-- Porta maior -->
      <div class="door-large flex justify-center">
        <Door />
      </div>
      
      <div class="window-group-large">
        <WindowGroup baseIndex={4} {cartas} {virarCarta} />
      </div>
      
      <div class="door-large flex justify-center">
        <Door />
      </div>
      
      <div class="window-group-large">
        <WindowGroup baseIndex={8} {cartas} {virarCarta} />
      </div>
      
      <!-- Porta adicional para equilibrar o design -->
      <div class="door-large flex justify-center">
        <Door />
      </div>
    {:else}
      <div class="col-span-6 p-8 text-center">
        <p class="text-xl">Carregando jogo...</p>
        <p class="text-lg text-gray-500 mt-2">Cartas: {cartas?.length || 0}/12</p>
      </div>
    {/if}
  </div>

  <!-- Detalhes adicionais do √¥nibus -->
  <!-- Far√≥is dianteiros -->
  <!-- <div class="absolute top-8 left-8 h-6 w-6 rounded-full bg-yellow-300 shadow-lg"></div>
  <div class="absolute top-16 left-8 h-6 w-6 rounded-full bg-yellow-300 shadow-lg"></div> -->
  
  <!-- Far√≥is traseiros -->
  <!-- <div class="absolute top-8 right-8 h-6 w-6 rounded-full bg-red-500 shadow-lg"></div>
  <div class="absolute top-16 right-8 h-6 w-6 rounded-full bg-red-500 shadow-lg"></div> -->

  <!-- Para-choque dianteiro -->
  <div class="absolute bottom-4 left-0 h-3 w-32 rounded-r-lg bg-gray-400"></div>
  
  <!-- Para-choque traseiro -->
  <div class="absolute bottom-4 right-0 h-3 w-32 rounded-l-lg bg-gray-400"></div>

  <!-- Rodas maiores e mais detalhadas -->
  <div class="absolute bottom-[-32px] left-40 h-24 w-24 rounded-full bg-black shadow-xl border-4 border-gray-600">
    <!-- Roda interna -->
    <div class="absolute inset-2 rounded-full bg-gray-700"></div>
    <!-- Centro da roda -->
    <div class="absolute inset-1/2 h-2 w-2 -translate-x-1/2 -translate-y-1/2 rounded-full bg-gray-400"></div>
  </div>
  
  <div class="absolute bottom-[-32px] right-40 h-24 w-24 rounded-full bg-black shadow-xl border-4 border-gray-600">
    <!-- Roda interna -->
    <div class="absolute inset-2 rounded-full bg-gray-700"></div>
    <!-- Centro da roda -->
    <div class="absolute inset-1/2 h-2 w-2 -translate-x-1/2 -translate-y-1/2 rounded-full bg-gray-400"></div>
  </div>

  <!-- Linha decorativa lateral -->
  <!-- <div class="absolute top-1/2 left-0 h-1 w-full bg-gradient-to-r from-blue-500 via-green-500 to-blue-500 -translate-y-1/2"></div> -->
</div>

<style>
  /* Usar tamanhos f√≠sicos ao inv√©s de transform scale */
  .window-group-large {
    transform: scale(1);
    font-size: 1.25em;
  }
  
  .door-large {
    transform: scale(1);
    width: 120px;
    height: auto;
  }
  
  /* Anima√ß√µes suaves para melhor experi√™ncia */
  .relative {
    transition: all 0.3s ease-in-out;
  }
  
  /* Responsividade para telas menores */
  @media (max-width: 1280px) {
    .max-w-\[1200px\] {
      max-width: 900px;
    }
    
    .window-group-large {
      font-size: 1.1em;
    }
  }
  
  @media (max-width: 768px) {
    .max-w-\[1200px\] {
      max-width: 100%;
      margin: 1rem;
    }
    
    .window-group-large {
      font-size: 0.9em;
    }
    
    .grid-cols-\[auto_120px_auto_120px_auto_120px\] {
      grid-template-columns: auto 80px auto 80px auto 80px;
    }
    
    .gap-x-8 {
      gap: 1rem;
    }
  }
</style>